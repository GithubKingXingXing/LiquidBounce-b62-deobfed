//Deobfuscated with https://github.com/PetoPetko/Minecraft-Deobfuscator3000 using mappings "mcp_stable-22-1.8.9 (1)"!

// 
// Decompiled by Procyon v0.5.36
// 

package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.minecraft.block.Block;
import net.ccbluex.liquidbounce.event.events.PushOutEvent;
import net.minecraft.util.MathHelper;
import net.ccbluex.liquidbounce.event.events.PacketEvent;
import net.minecraft.util.AxisAlignedBB;
import net.ccbluex.liquidbounce.event.events.BlockBBEvent;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.minecraft.client.network.NetHandlerPlayClient;
import net.minecraft.util.BlockPos;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.minecraft.block.BlockAir;
import net.ccbluex.liquidbounce.event.events.UpdateEvent;
import joptsimple.internal.Strings;
import net.minecraft.client.audio.ISound;
import net.minecraft.client.audio.PositionedSoundRecord;
import net.minecraft.util.ResourceLocation;
import net.ccbluex.liquidbounce.features.command.Command;
import net.ccbluex.liquidbounce.LiquidBounce;
import net.ccbluex.liquidbounce.utils.timer.TickTimer;
import net.ccbluex.liquidbounce.valuesystem.types.ListValue;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.features.module.Module;

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
public class Phase extends Module
{
    private final ListValue modeValue;
    private final TickTimer tickTimer;
    private boolean mineplexClip;
    private TickTimer mineplexTickTimer;
    
    public Phase() {
        this.modeValue = new ListValue("Mode", new String[] { "Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex" }, "Vanilla");
        this.tickTimer = new TickTimer();
        this.mineplexTickTimer = new TickTimer();
        LiquidBounce.CLIENT.commandManager.registerCommand(new Command("phase", null) {
            @Override
            public void execute(final String[] args) {
                if (args.length <= 1 || !args[1].equalsIgnoreCase("mode")) {
                    this.chatSyntax(".phase <mode>");
                    return;
                }
                if (args.length > 2 && Phase.this.modeValue.contains(args[2])) {
                    Phase.this.modeValue.setValue(args[2].toLowerCase());
                    this.chat("§7Phase mode was set to §8" + Phase.this.modeValue.asString().toUpperCase() + "§7.");
                    Phase$1.mc.getSoundHandler().playSound((ISound)PositionedSoundRecord.create(new ResourceLocation("random.anvil_use"), 1.0f));
                    return;
                }
                this.chatSyntax(".phase mode §c<§8" + Strings.join(Phase.this.modeValue.getValues(), "§7, §8") + "§c>");
            }
        });
    }
    
    @EventTarget
    public void onUpdate(final UpdateEvent event) {
        final boolean isInsideBlock = BlockUtils.collideBlockIntersects(Phase.mc.thePlayer.getEntityBoundingBox(), block -> !(block instanceof BlockAir));
        if (isInsideBlock && !this.modeValue.asString().equalsIgnoreCase("Mineplex")) {
            Phase.mc.thePlayer.noClip = true;
            Phase.mc.thePlayer.motionY = 0.0;
            Phase.mc.thePlayer.onGround = true;
        }
        final NetHandlerPlayClient netHandlerPlayClient = Phase.mc.getNetHandler();
        final String lowerCase = this.modeValue.asString().toLowerCase();
        switch (lowerCase) {
            case "vanilla": {
                if (!Phase.mc.thePlayer.onGround || !this.tickTimer.hasTimePassed(2) || !Phase.mc.thePlayer.isCollidedHorizontally) {
                    break;
                }
                if (isInsideBlock && !Phase.mc.thePlayer.isSneaking()) {
                    break;
                }
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY + 0.2, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX + 0.5, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + 0.5, true));
                final double yaw = Math.toRadians(Phase.mc.thePlayer.rotationYaw);
                final double x = -Math.sin(yaw) * 0.04;
                final double z = Math.cos(yaw) * 0.04;
                Phase.mc.thePlayer.setPosition(Phase.mc.thePlayer.posX + x, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + z);
                this.tickTimer.reset();
                break;
            }
            case "skip": {
                if (!Phase.mc.thePlayer.onGround || !this.tickTimer.hasTimePassed(2) || !Phase.mc.thePlayer.isCollidedHorizontally) {
                    break;
                }
                if (isInsideBlock && !Phase.mc.thePlayer.isSneaking()) {
                    break;
                }
                final double direction = MovementUtils.getDirection();
                final double posX = -Math.sin(direction) * 0.3;
                final double posZ = Math.cos(direction) * 0.3;
                for (int i = 0; i < 3; ++i) {
                    Phase.mc.getNetHandler().addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY + 0.06, Phase.mc.thePlayer.posZ, true));
                    Phase.mc.getNetHandler().addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX + posX * i, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + posZ * i, true));
                }
                Phase.mc.thePlayer.setEntityBoundingBox(Phase.mc.thePlayer.getEntityBoundingBox().offset(posX, 0.0, posZ));
                Phase.mc.thePlayer.setPositionAndUpdate(Phase.mc.thePlayer.posX + posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + posZ);
                this.tickTimer.reset();
                break;
            }
            case "spartan": {
                if (!Phase.mc.thePlayer.onGround || !this.tickTimer.hasTimePassed(2) || !Phase.mc.thePlayer.isCollidedHorizontally) {
                    break;
                }
                if (isInsideBlock && !Phase.mc.thePlayer.isSneaking()) {
                    break;
                }
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX, Phase.mc.thePlayer.posY - 0.2, Phase.mc.thePlayer.posZ, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue((Packet)new C03PacketPlayer.C04PacketPlayerPosition(Phase.mc.thePlayer.posX + 0.5, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + 0.5, true));
                final double yaw = Math.toRadians(Phase.mc.thePlayer.rotationYaw);
                final double x = -Math.sin(yaw) * 0.04;
                final double z = Math.cos(yaw) * 0.04;
                Phase.mc.thePlayer.setPosition(Phase.mc.thePlayer.posX + x, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + z);
                this.tickTimer.reset();
                break;
            }
            case "clip": {
                if (!this.tickTimer.hasTimePassed(2) || !Phase.mc.thePlayer.isCollidedHorizontally) {
                    break;
                }
                if (isInsideBlock && !Phase.mc.thePlayer.isSneaking()) {
                    break;
                }
                final double yaw = Math.toRadians(Phase.mc.thePlayer.rotationYaw);
                final double oldX = Phase.mc.thePlayer.posX;
                final double oldZ = Phase.mc.thePlayer.posZ;
                for (int i = 1; i <= 10; ++i) {
                    final double x2 = -Math.sin(yaw) * i;
                    final double z2 = Math.cos(yaw) * i;
                    if (BlockUtils.getBlock(new BlockPos(oldX + x2, Phase.mc.thePlayer.posY, oldZ + z2)) instanceof BlockAir && BlockUtils.getBlock(new BlockPos(oldX + x2, Phase.mc.thePlayer.posY + 1.0, oldZ + z2)) instanceof BlockAir) {
                        Phase.mc.thePlayer.setPosition(oldX + x2, Phase.mc.thePlayer.posY, oldZ + z2);
                        break;
                    }
                }
                this.tickTimer.reset();
                break;
            }
            case "aac3.5.0": {
                if (!this.tickTimer.hasTimePassed(2) || !Phase.mc.thePlayer.isCollidedHorizontally) {
                    break;
                }
                if (isInsideBlock && !Phase.mc.thePlayer.isSneaking()) {
                    break;
                }
                final double yaw = Math.toRadians(Phase.mc.thePlayer.rotationYaw);
                final double oldX = Phase.mc.thePlayer.posX;
                final double oldZ = Phase.mc.thePlayer.posZ;
                final double x3 = -Math.sin(yaw);
                final double z3 = Math.cos(yaw);
                Phase.mc.thePlayer.setPosition(oldX + x3, Phase.mc.thePlayer.posY, oldZ + z3);
                this.tickTimer.reset();
                break;
            }
            case "mineplex": {
                if (Phase.mc.thePlayer.isCollidedHorizontally) {
                    this.mineplexClip = true;
                }
                if (!this.mineplexClip) {
                    break;
                }
                this.mineplexTickTimer.update();
                Phase.mc.thePlayer.onGround = false;
                Phase.mc.thePlayer.motionX = 0.0;
                Phase.mc.thePlayer.motionZ = 0.0;
                Phase.mc.thePlayer.motionY = 0.0;
                Phase.mc.thePlayer.jumpMovementFactor = 0.0f;
                if (this.mineplexTickTimer.hasTimePassed(3)) {
                    this.mineplexTickTimer.reset();
                    this.mineplexClip = false;
                    break;
                }
                if (this.mineplexTickTimer.hasTimePassed(1)) {
                    final double offset = this.mineplexTickTimer.hasTimePassed(2) ? 1.6 : 0.06;
                    final double direction2 = MovementUtils.getDirection();
                    Phase.mc.thePlayer.setPosition(Phase.mc.thePlayer.posX + -Math.sin(direction2) * offset, Phase.mc.thePlayer.posY, Phase.mc.thePlayer.posZ + Math.cos(direction2) * offset);
                    break;
                }
                break;
            }
        }
        this.tickTimer.update();
    }
    
    @EventTarget
    public void onBlockBB(final BlockBBEvent event) {
        if (Phase.mc.thePlayer != null && BlockUtils.collideBlockIntersects(Phase.mc.thePlayer.getEntityBoundingBox(), block -> !(block instanceof BlockAir)) && event.getBoundingBox() != null && event.getBoundingBox().maxY > Phase.mc.thePlayer.getEntityBoundingBox().minY && !this.modeValue.asString().equalsIgnoreCase("Mineplex")) {
            final AxisAlignedBB axisAlignedBB = event.getBoundingBox();
            event.setBoundingBox(new AxisAlignedBB(axisAlignedBB.maxX, Phase.mc.thePlayer.getEntityBoundingBox().minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ));
        }
    }
    
    @EventTarget
    public void onPacket(final PacketEvent event) {
        final Packet packet = event.getPacket();
        if (packet instanceof C03PacketPlayer) {
            final C03PacketPlayer packetPlayer = (C03PacketPlayer)packet;
            if (this.modeValue.asString().equalsIgnoreCase("AAC3.5.0")) {
                final float yaw = (float)MovementUtils.getDirection();
                packetPlayer.x -= MathHelper.sin(yaw) * 1.0E-8;
                packetPlayer.z += MathHelper.cos(yaw) * 1.0E-8;
            }
        }
    }
    
    @EventTarget
    public void onPushOut(final PushOutEvent event) {
        event.setCancelled(true);
    }
    
    @Override
    public String getTag() {
        return this.modeValue.asString();
    }
}
